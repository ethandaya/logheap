[sources.log_http]
type = "http_server"
address = "0.0.0.0:3030"
framing.method = "newline_delimited"
decoding.codec = "json"

[transforms.explode_logs]
type = "remap"
inputs = ["log_http"]
source = '''
_timestamp = to_unix_timestamp(now())
_namespace = ._namespace;
raw_source = .
del(raw_source._namespace);
source = encode_json(raw_source)
raw_source = flatten(raw_source)
. = {}

.string_names = []
.string_values = []
.number_names = []
.number_values = []
.bool_names = []
.bool_values = []
.array_values = []
.array_names = []

.accounts = []
.transactions = []
.checksum_addresses = []

for_each(array(keys(raw_source))) -> |_index, value| {
    v = get!(raw_source, [value]);
    if is_string(v){
        .string_names = push(.string_names, value)
        .string_values = push(.string_values, v)
    } else if is_integer(v) || is_float(v) {
        .number_names = push(.number_names, value)
        .number_values = push(.number_values, v)
    } else if is_boolean(v){
        .bool_names = push(.bool_names, value)
        .bool_values = push(.bool_values, v)
    } else if is_array(v){
        v = map_values(array!(v)) -> |vv| {
            if !is_object(vv) && !is_array(vv) || is_integer(v) || is_float(v) {
                to_string!(vv)
            } else {
                encode_json(vv)
            }
        }
        .array_names = push(.array_names, value)
        .array_values = push(.array_values, v)
    }
}

result, err = parse_regex_all(source, r'(?P<address>0x[0-9a-fA-F]{40})')
.accounts = unique(map_values(result) -> |value| { get!(value, ["address"]) })

result, err = parse_regex_all(source, r'(?P<txhash>0x[0-9a-fA-F]{64})')
.transactions = unique(map_values(result) -> |value| { get!(value, ["txhash"]) })

.source = source
._timestamp = _timestamp;
._namespace = _namespace
'''

[sinks.clickhouse]
inputs = ["explode_logs"]
type = "clickhouse"
endpoint = "http://clickhouse-server:8123"
table = "logs"
